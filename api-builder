#!/usr/bin/env python

#############################################################################
# Author  : Jerome ODIER, Christophe SMEKENS, Francois SMEKENS
# Email   : ---@gmail.com, ---@gmail.com, ---@gmail.com
#
# Version : 1.0 beta (2012)
#
#
# This file is part of API-BUILDER.
#
#  u-autotool is free software; you can redistribute it and/or modify
#  it under the terms of the GNU Lesser General Public License as published
#  by the Free Software Foundation; either version 3 of the License, or
#  (at your option) any later version.
#
#  u-autotool is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU Lesser General Public License for more details.
#
#  You should have received a copy of the GNU Lesser General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#############################################################################

import os, sys, xml.dom.minidom

#############################################################################

if sys.version_info < (3,): range = xrange

#############################################################################
# GLOBAL VARIABLES							    #
#############################################################################

verbose = False

#############################################################################

INT_ASSET = {}
INT_TYPES = {}
INT_PROFILES = {}
INT_EXTENSIONS = []
INT_CONSTRAINTS = {}

#############################################################################

IMP_EXTRAS = {}
IMP_INITS = {}
IMP_EXTENSIONS = {}

#############################################################################

LANG = None

#############################################################################

def getTEXTs(self):
	L = []

	for textensionNode in self.childNodes:
		if textensionNode.nodeType == 3:
			L.append(textensionNode.nodeValue)

	return L

xml.dom.minidom.Element.getTEXTs = getTEXTs

#############################################################################

def getCDATAs(self):
	L = []

	for textensionNode in self.childNodes:
		if textensionNode.nodeType == 4:
			L.append(textensionNode.nodeValue)

	return L

xml.dom.minidom.Element.getCDATAs = getCDATAs

#############################################################################

def myprint(s, level):

	for i in xrange(level):
		sys.stdout.write(' ')

	print(s)

#############################################################################

def displayTree(T, level = 0):

		if   type(T).__name__ == 'list':

			for item in enumerate(T):

				myprint('idx: %d' % item[0], level)

				displayTree(item[1], level + 4)

		elif type(T).__name__ == 'dict':

			for item in T.iteritems():

				myprint('key: %s' % item[0], level)

				displayTree(item[1], level + 4)

		else:
			myprint(T, level)

#############################################################################
# PARSERS								    #
#############################################################################

def parseInterfaceNodes(interfaces):
	#####################################################################

	if len(interfaces) != 1:
		print('[Error] Only one interface allowed !')

		sys.exit(1)

	interface = interfaces[0]

	#####################################################################

	date = ''
	authors = ''
	description = ''

	#####################################################################

	for node in interface.childNodes:

		#############################################################

		if node.nodeName == 'asset':

			for assetNode in node.childNodes:

				if assetNode.nodeName == 'date':
					date = assetNode.getTEXTs()[0]
				if assetNode.nodeName == 'authors':
					authors = assetNode.getTEXTs()[0]
				if assetNode.nodeName == 'description':
					description = assetNode.getTEXTs()[0]

		#############################################################

		if node.nodeName == 'types':

			TYPE = {}
			ENUM = {}
			STRUCT = {}

			for typeNode in node.childNodes:

				#############################################

				if typeNode.nodeName == 'type':

					dic = {
						'from': typeNode.getAttribute('from')
					}

					TYPE[typeNode.getAttribute('name')] = dic

				#############################################

				if typeNode.nodeName == 'enum':

					VALUES = []

					for valueNode in typeNode.childNodes:

						#############################

						if valueNode.nodeName == 'value':

							dic = {
								'name': valueNode.getAttribute('name')
							}

							VALUES.append(dic)

					dic = {
						'values': VALUES
					}

					ENUM[typeNode.getAttribute('name')] = dic


				#############################################

				if typeNode.nodeName == 'struct':

					FIELDS = []

					for fieldNode in typeNode.childNodes:

						#############################

						if fieldNode.nodeName == 'field':

							dic = {
								'name': fieldNode.getAttribute('name'),
								'type': fieldNode.getAttribute('type'),
							}

							FIELDS.append(dic)

					dic = {
						'fields': FIELDS
					}

					STRUCT[typeNode.getAttribute('name')] = dic

			#####################################################

			INT_TYPES['types'] = TYPE
			INT_TYPES['enums'] = ENUM
			INT_TYPES['structs'] = STRUCT

		#############################################################

		if node.nodeName == 'profiles':

			for profileNode in node.childNodes:

				#############################################

				if profileNode.nodeName == 'profile':

					dic = {
					}

					INT_PROFILES[profileNode.getAttribute('name')] = dic

		#############################################################

		if node.nodeName == 'extensions':

			for extensionNode in node.childNodes:

				#############################################

				if extensionNode.nodeName == 'extension':

					METHODS = []

					for methodNode in extensionNode.childNodes:

						#############################

						if methodNode.nodeName == 'method':

							PARAMS = []

							for paramNode in methodNode.childNodes:

								#############

								if paramNode.nodeName == 'param':

									dic = {
										'name': paramNode.getAttribute('name'),
										'type': paramNode.getAttribute('type'),
									}

									PARAMS.append(dic)

							dic = {
								'name': methodNode.getAttribute('name'),
								'type': methodNode.getAttribute('type'),
								'params': PARAMS
							}

							METHODS.append(dic)

					dic = {
						'name': extensionNode.getAttribute('name'),
					#	'type': extensionNode.getAttribute('type'),
						'methods': METHODS
					}

					INT_EXTENSIONS.append(dic)

		#############################################################

		if node.nodeName == 'constraints':

			for constraintNode in node.childNodes:

				#############################################

				if constraintNode.nodeName == 'constraint':

					KEYS = {}

					for keyNode in constraintNode.childNodes:

						#############################

						if keyNode.nodeName == 'key':

							dic = {
							}

							KEYS[keyNode.getAttribute('name')] = dic

					dic = {
						'keys': KEYS
					}

					INT_CONSTRAINTS[constraintNode.getAttribute('name')] = dic

	#####################################################################

	INT_ASSET['date'] = date
	INT_ASSET['authors'] = authors
	INT_ASSET['description'] = description

	#####################################################################

	if verbose:
		print('-----------------------------------------------------------------------------')
		print('| ASSET                                                                     |')
		print('-----------------------------------------------------------------------------')
		displayTree(INT_ASSET)
		print('-----------------------------------------------------------------------------')
		print('| TYPES                                                                     |')
		print('-----------------------------------------------------------------------------')
		displayTree(INT_TYPES)
		print('-----------------------------------------------------------------------------')
		print('| PROFILES                                                                  |')
		print('-----------------------------------------------------------------------------')
		displayTree(INT_PROFILES)
		print('-----------------------------------------------------------------------------')
		print('| EXTENSIONS                                                                |')
		print('-----------------------------------------------------------------------------')
		displayTree(INT_EXTENSIONS)
		print('-----------------------------------------------------------------------------')
		print('| CONSTRAINTS                                                               |')
		print('-----------------------------------------------------------------------------')
		displayTree(INT_CONSTRAINTS)
		print('-----------------------------------------------------------------------------')
		print('')

#############################################################################

def parseProfileCode(node):
	#####################################################################

	PROFILES = {}

	for profile in node.childNodes:

		#############################################################

		if profile.nodeName == 'profile':

			CODES = []

			for codeNode in profile.childNodes:

				#############################################

				if codeNode.nodeName == 'code':

					TXTS = []

					for cdataNode in codeNode.childNodes:

						if cdataNode.nodeType == 4:

							TXTS.append(cdataNode.nodeValue)

					dic = {
						'condition': codeNode.getAttribute('condition'),
						'txts': TXTS
					}

					CODES.append(dic)

			dic = {
				'codes': CODES
			}

			PROFILES[profile.getAttribute('name')] = dic

	return PROFILES

#############################################################################

def parseImplementationNodes(implementations):
	#####################################################################

	if len(implementations) != 1:
		print('[Error] Only one implementation allowed !')

		sys.exit(1)

	implementation = implementations[0]

	#####################################################################

	for node in implementation.childNodes:

		#############################################################

		if node.nodeName == 'extras':

			IMP_EXTRAS['profiles'] = parseProfileCode(node)
			IMP_EXTRAS['code'] = node.getCDATAs()[0]

		#############################################################

		if node.nodeName == 'inits':

			IMP_INITS['profiles'] = parseProfileCode(node)
			IMP_INITS['code'] = node.getCDATAs()[0]

	#####################################################################

		if node.nodeName == 'extensions':

			for extensionNode in node.childNodes:

				#############################################

				if extensionNode.nodeName == 'extension':

					METHODS = {}

					for methodNode in extensionNode.childNodes:

						#############################

						if methodNode.nodeName == 'method':

							dic = {
								'profiles': parseProfileCode(methodNode)
							}

							METHODS[methodNode.getAttribute('name')] = dic

					dic = {
						'methods': METHODS
					}

					IMP_EXTENSIONS[extensionNode.getAttribute('name')] = dic

	#####################################################################

	if verbose:
		print('-----------------------------------------------------------------------------')
		print('| EXTRAS                                                                    |')
		print('-----------------------------------------------------------------------------')
		displayTree(IMP_EXTRAS)
		print('-----------------------------------------------------------------------------')
		print('| INITS                                                                     |')
		print('-----------------------------------------------------------------------------')
		displayTree(IMP_INITS)
		print('-----------------------------------------------------------------------------')
		print('| EXTENSIONS                                                                |')
		print('-----------------------------------------------------------------------------')
		displayTree(IMP_EXTENSIONS)
		print('-----------------------------------------------------------------------------')
		print('')

#############################################################################
# API-BUILDER								    #
#############################################################################

def apibuilder_load(fileName):
	#####################################################################

	try:
		doc = xml.dom.minidom.parse(fileName)

	except:
		print('[Error] XML error in file `%s` !' % fileName)

		sys.exit(1)

	#####################################################################

	for include in doc.getElementsByTagName('include'):

		for url in buildPaths(include.getAttribute('url')):

			apibuilder_load(url, config)

	#####################################################################

	parseInterfaceNodes(doc.getElementsByTagName('interface'))
	parseImplementationNodes(doc.getElementsByTagName('implementation'))

#############################################################################

def apibuilder_check():

	DEBUG = 0
	ERROR = 0
	WARNING = 0

	#####################################################################
	#####################################################################
	## INTERFACE							   ##
	#####################################################################
	#####################################################################

	#####################################################################
	# TYPES - PASS 1						    #
	#####################################################################

	L = []

	L.extend(LANG.PRIMITIVE)

	for name in INT_TYPES['types']:
		L.append(name)
	for name in INT_TYPES['enums']:
		L.append(name)
	for name in INT_TYPES['structs']:
		L.append(name)

	#####################################################################
	# TYPES - PASS 2						    #
	#####################################################################

	for t in INT_TYPES['types'].iteritems():

		if t[1]['from'] in L:
			if t[1]['from'] == t[0]:
				print('[Error] Recursif type \'%s\' !' % t[1]['from'])
				ERROR += 1
		else:
			print('[Error] Undifined type \'%s\' !' % t[1]['from'])
			ERROR += 1

	#####################################################################

	for t in INT_TYPES['enums']:

		for u in INT_TYPES['enums'][t]:

			v = INT_TYPES['enums'][t][u]

			for i in xrange(0 + 0, len(v)):
				for j in xrange(i + 1, len(v)):

					if v[i]['name'] == v[j]['name']:

						print('[Error] Duplicated values \'%s\' and \'%s\' !' % (v[i]['name'], v[j]['name']))
						ERROR += 1

	#####################################################################

	for t_0_ in INT_TYPES['structs']:

		for u in INT_TYPES['structs'][t_0_].iteritems():

			for v in u[1]:

				if v['type'] in L:
					if v['type'] == t_0_:
						print('[Debug] Undifined type \'%s\' !' % v['type'])
						DEBUG += 1
				else:
					print('[Error] Undifined type \'%s\' !' % v['type'])
					ERROR += 1

	#####################################################################
	# METHODS							    #
	#####################################################################

	EXTENSIONS = []
	METHODS = []

	for e in INT_EXTENSIONS:

		for m in e['methods']:

			for p in m['params']:

				if not p['type'] in L:
					print('[Error] Undifined type \'%s\' !' % p['type'])
					ERROR += 1

			##

			p = m['params']

			for i in xrange(0 + 0, len(p)):
				for j in xrange(i + 1, len(p)):

					if p[i]['name'] == p[j]['name']:

						print('[Error] Duplicated parameter \'%s\' and \'%s\' !' % (p[i]['name'], p[j]['name']))
						ERROR += 1

		m = e['methods']

		for i in xrange(0 + 0, len(m)):
			for j in xrange(i + 1, len(m)):

				if m[i]['name'] == m[j]['name']:

					print('[Error] Duplicated method \'%s\' and \'%s\' !' % (m[i]['name'], m[j]['name']))
					ERROR += 1

	e = INT_EXTENSIONS

	for i in xrange(0 + 0, len(e)):
		for j in xrange(i + 1, len(e)):

			if e[i]['name'] == e[j]['name']:

				print('[Error] Duplicated extension \'%s\' and \'%s\' !' % (e[i]['name'], e[j]['name']))
				ERROR += 1

	#####################################################################
	#####################################################################
	## IMPLEMENTATION						   ##
	#####################################################################
	#####################################################################

	#####################################################################
	# EXTRAS							    #
	#####################################################################

	for profile in IMP_EXTRAS['profiles']:

		if INT_PROFILES.has_key(profile) == False:
			print('[Error] Undifined profile \'%s\' !' % profile)
			ERROR += 1

	#####################################################################
	# INITS								    #
	#####################################################################

	for profile in IMP_INITS['profiles']:

		if INT_PROFILES.has_key(profile) == False:
			print('[Error] Undifined profile \'%s\' !' % profile)
			ERROR += 1

	#####################################################################
	# EXTENSIONS							    #
	#####################################################################

	for extension in IMP_EXTENSIONS:

		L = [e['name']                       for e in INT_EXTENSIONS]
		M = [m['name'] for m in e['methods'] for e in INT_EXTENSIONS]

		##

		if not extension in L:
			print('[Error] Undifined extension \'%s\' !' % extension)
			ERROR += 1

		for method in IMP_EXTENSIONS[extension]['methods']:

			if not method in M:
				print('[Error] Undifined method \'%s\' !' % method)
				ERROR += 1

			##

			IMP_METHODS = IMP_EXTENSIONS \
					     [extension]['methods']

			##

			for profile in IMP_METHODS[method]['profiles']:

				if INT_PROFILES.has_key(profile) == False:
					print('[Error] Undifined profile \'%s\' !' % profile)
					ERROR += 1

	#####################################################################

	if DEBUG > 0  \
	   or         \
	   ERROR > 0  \
	   or         \
	   WARNING > 0:
		print('')

		if DEBUG > 0:
			print('There are %d debugs !' % DEBUG)

		if ERROR > 0:
			print('There are %d errors !' % ERROR)

		if WARNING > 0:
			print('There are %d warnings !' % WARNING)

#############################################################################

def apibuilder_emit():
	#####################################################################

	pass

#############################################################################

from optparse import OptionParser

#############################################################################

if __name__ == '__main__':
	#####################################################################

	parser = OptionParser('usage: %prog [options] [filename]')

	parser.add_option('-a', '--authors',
			action='store_true', dest='authors', help='show authors')
	parser.add_option('-v', '--version',
			action='store_true', dest='version', help='show version')
	parser.add_option('-l', '--lang',
			action='store', dest='lang', help='???')
	parser.add_option('', '--verbose',
			action='store_true', dest='verbose', help='set %prog verbose')

	(options, args) = parser.parse_args()

	verbose = options.verbose

	#####################################################################

	if options.authors:
		print('Jerome ODIER, Christophe SMEKENS, Francois SMEKENS')
		sys.exit()

	if options.version:
		print('api-builder-1.0')
		sys.exit()

	#####################################################################

	list = [
		'ApiBuilder.xml',
	]

	if   len(args) == 0:
		fileName = os.path.normcase(list[0])
	elif len(args) == 1:
		fileName = os.path.normcase(args[0])
	else:
		parser.error('syntax error')
		sys.exit(1)

	#####################################################################

	if not os.path.exists(fileName):
		parser.error('incorrect filename \'%s\'' % fileName)
		sys.exit(1)

	#####################################################################

	try:
		if options.lang:
			LANG = __import__('lang_%s' % options.lang)
		else:
			LANG = __import__('lang_%s' %     'c'     )

	except ImportError, e:
		parser.error('incorrect language \'%s\'' % options.lang)
		sys.exit(1)

	#####################################################################

	apibuilder_load(fileName)

	apibuilder_check()
	apibuilder_emit()

#############################################################################

